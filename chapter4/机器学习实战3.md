# 机器学习实战三（Naive Bayes）

前两章的两种分类算法，是确定的分类器，但是有时会产生一些错误的分类结果，这时可以要求分类器给出一个最优的猜测结果，估计概率。朴素贝叶斯就是其中一种。

学过概率论的人对于贝叶斯这个名字应该是相当的熟悉，在学条件概率的时候，贝叶斯公式可谓是一针见血。这里的“朴素贝叶斯”，是因为在计算贝叶斯概率的时候只考虑最原始、最简单的假设。

## Naive Bayes(朴素贝叶斯)

> 优点：在数据较少的情况下依然有效，可处理多类别问题。
> 
> 缺点：对于输入数据的格式要求严格。

原理：朴素贝叶斯的原理十分简单，如果假定数据有两类，分别计算待分类数据属于这两类的概率，p1和p2，如果
- p1 > p2, 则属于类别1
- p1 < p2, 则属于类别2


略微提及一下贝叶斯公式：
$p\left( c|x\right) =\dfrac {p\left( x|c\right) p\left( c\right) }{p\left( x\right) }$。

这个公式的强大之处在于，可以将先验概率和后验概率进行转换，看起来简单，但是使用的时候的确很强大，而且计算很便捷。

先来看朴素贝叶斯的两个基本假设：
- 文本之间相互独立
- 每个特征同等重要

根据这两个基本假设，就可以着手构造分类器了。

首先要将文本转换到向量空间,思路比较清晰。
```
import feedparser
import numpy as np
import operator
import random
import re

# 加载测试数据
def loadDataSet():
    postingList = [['my', 'dog', 'has', 'flea', 'problems', 'help', 'please'],
                   ['maybe', 'not', 'take', 'him', 'to', 'dog', 'park', 'stupid'],
                   ['my', 'dalmation', 'is', 'so', 'cute', 'I', 'love', 'him'],
                   ['stop', 'posting', 'stupid', 'worthless', 'garbage'],
                   ['mr', 'licks', 'ate', 'my', 'steak', 'how', 'to', 'stop', 'him'],
                   ['quit', 'buying', 'worthless', 'dog', 'food', 'stupid']]
    classVec = [0, 1, 0, 1, 0, 1]
    return postingList, classVec


# 创建词汇表
def createVocabList(dataSet):
    vocabSet = set()
    for document in dataSet:
        vocabSet = vocabSet | set(document)
    return list(vocabSet)


# 构造文档向量
def setOfWord2Vec(vocabList, inputSet):
    returnVec = [0] * len(vocabList)
    for word in inputSet:
        if word in vocabList:
            returnVec[vocabList.index(word)] = 1
        else:
            print('the word: {} is not in my Vocabulary!'.format(word))
    return returnVec
```

下一步是训练算法，从词向量计算概率，但是这里有几个小技巧：
- 分母的初始值设置为2，避免分母为0的情况出现
- 由于特征之间独立，在做乘法的时候有时会面临小数位数过多的下溢出，这时可以将其转化为对数形式，这是一种比较通常的解决思路

```
# 训练函数
def trainNB0(trainMatrix, trainCategory):
    numTrainDocs = len(trainMatrix)
    numWords = len(trainMatrix[0])
    pAbusive = np.sum(trainCategory) / numTrainDocs
    p0Num = np.ones(numWords)
    p1Num = np.ones(numWords)
    p0Denom = 2.0
    p1Denom = 2.0
    for i in range(numTrainDocs):
        if trainCategory[i] == 1:
            p1Num += trainMatrix[i]
            p1Denom += np.sum(trainMatrix[i])
        else:
            p0Num += trainMatrix[i]
            p0Denom += np.sum(trainMatrix[i])
    p1Vect = np.log(p1Num / p1Denom)
    p0Vect = np.log(p0Num / p0Denom)
    return p0Vect, p1Vect, pAbusive
```
这种分类方式称为`词集模型`，只考虑某个词出不出现，如果一种词出现不止一次，那么统计出现的次数无疑会包含更多信息，这种方法称为`词袋模型`。
```
# 词袋模型
def bagofWords2VecMN(vocabList, inputSet):
    returnVec = [0] * len(vocabList)
    for word in inputSet:
        if word in vocabList:
            returnVec[vocabList.index(word)] += 1
    return returnVec
```
变化其实并不大。

现在就可以执行分类了,这一步完全就是条件概率公式的应用，注意对数可以将相乘转换为相加。
```
# 执行分类
def classifyNB(vect2Classify, p0Vec, p1Vec, pClass1):
    # 对数相乘转换为相加
    p1 = np.sum(vect2Classify * p1Vec) + np.log(pClass1)
    p0 = np.sum(vect2Classify * p0Vec) + np.log(1.0 - pClass1)
    if p1 > p0:
        return 1
    else:
        return 0
```
原书中提供的两个关于朴素贝叶斯应用的例子，一个是过滤垃圾邮件，另一个是从个人广告中获取区域倾向，都是很有趣的例子，代码可以在[我的Github]()中找到。

例子中有几点需要注意：

1.留存交叉验证，其实就是从样本集中随机选取一部分作为训练集，剩下的作为预测集来检验精度。

2.高频词通常移除会带来更好的分类效果。

3.停用词也可以选择剔除。

> Naive Bayes存在的问题：
> 
> 通过降级特征之间的条件独立性假设降低对数据量的需求，有时这个假设会显得过于简单，但是朴素贝叶斯仍是一种有效的分类器，而且使用概率要比使用硬规则更为有效。

**Next:初次接触优化算法和Logistic回归**

***
**总结：概率在机器学习中的应用是广泛的，这是因为很多时候我们对于事物的具体发生机理并不了解，这个时候就需要借助概率论和统计的力量。**

*References:https://github.com/plantree/Machine-Learing-In-Action/tree/master/chapter4*